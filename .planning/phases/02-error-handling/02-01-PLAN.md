---
phase: 02-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/components/AsyncErrorBoundary.tsx
  - src/lib/tmdb.ts
  - src/lib/tmdbCache.ts
autonomous: true
requirements:
  - ERR-01
  - ERR-04

must_haves:
  truths:
    - "Extended AsyncErrorBoundary includes error codes for debugging"
    - "Extended AsyncErrorBoundary requires manual dismiss (no auto-dismiss)"
    - "Error messages include component name"
    - "Errors appear near failed component (not top of viewport)"
    - "TMDB uses in-memory cache with 24-hour expiration"
    - "TMDB serves only fresh cached data (strict fresh, no stale-while-revalidate)"
    - "Silent fallback to cache without showing error UI to user"
  artifacts:
    - path: "src/app/components/AsyncErrorBoundary.tsx"
      provides: "Enhanced error boundary with error codes, manual dismiss, component name"
      contains: "errorCode, dismissButton, componentName props"
    - path: "src/lib/tmdb.ts"
      provides: "TMDB API with in-memory caching"
      contains: "tmdbCache.ts import, cache.get, cache.set"
  key_links:
    - from: "src/app/components/AsyncErrorBoundary.tsx"
      to: "src/lib/logger"
      via: "logError calls"
      pattern: "logError.*AsyncErrorBoundary"
---

<objective>
Extend AsyncErrorBoundary with error codes, manual dismiss, and component-specific error messages. Enhance TMDB with in-memory 24-hour cache for graceful degradation.
</objective>

<execution_context>
@C:/Users/n0rds/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/n0rds/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-handling/02-CONTEXT.md
@src/app/components/AsyncErrorBoundarysrc/lib/tm.tsx
@db.ts

# User Decisions (LOCKED - implement exactly):
- Error message style: include error codes, manual dismiss required, appear near failed component, user-friendly with error codes
- Error boundary scope: extend existing AsyncErrorBoundary, no auto retry, component-specific messages, include component name
- TMDB fallback: 24-hour cache, in-memory (not Redis), strict fresh, silent fallback
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AsyncErrorBoundary with error codes and manual dismiss</name>
  <files>src/app/components/AsyncErrorBoundary.tsx</files>
  <action>
    Extend AsyncErrorBoundary component to include:
    - Add unique error code for each error (format: "ERR-{timestamp}" or sequential)
    - Add manual dismiss button (no auto-dismiss)
    - Add component name prop to display in error message
    - Position error near failed component (inline, not viewport top)
    - Use consistent styling (red border, user-friendly message + error code)
    - Auto-log errors to console via logError with component context
    - No automatic retry - manual refresh button only
    
    Per user decision: "Include error codes for debugging", "Manual dismiss required (no auto-dismiss)", "Appear near the failed component", "Include component name in error messages", "Extend existing AsyncErrorBoundary (don't create new)"
  </action>
  <verify>
    1. Check AsyncErrorBoundary.tsx has error code generation
    2. Check has manual dismiss button with onClick handler
    3. Check accepts componentName prop and displays it
    4. Verify styling is inline (not fixed top)
    5. Verify logError is called with context
    6. Verify no auto-dismiss or auto-retry logic
  </verify>
  <done>
    AsyncErrorBoundary shows error code, requires manual dismiss, displays component name, appears near failed component, logs to console. User must manually dismiss or refresh - no auto-dismiss.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add in-memory cache to TMDB with 24-hour expiration</name>
  <files>src/lib/tmdbCache.ts, src/lib/tmdb.ts</files>
  <action>
    Create in-memory cache module and integrate with TMDB:
    
    1. Create src/lib/tmdbCache.ts with:
       - In-memory Map cache (not Redis)
       - 24-hour TTL (86400000 ms)
       - get(key): returns cached data only if fresh
       - set(key, data): stores with timestamp
       - Strict fresh: returns null if data is older than 24h
    
    2. Update src/lib/tmdb.ts to use cache:
       - Import tmdbCache
       - Cache all successful TMDB responses
       - On API failure: check cache first, return cached if fresh
       - Silent fallback: return cached data without showing error UI
       - Per user decision: "Strict fresh: only serve cached data when fresh (no stale-while-revalidate)", "Silent fallback (auto-fallback without showing errors)"
    
    Note: TMDB already has mock fallback - enhance it with proper in-memory caching instead of just returning mock data
  </action>
  <verify>
    1. Check tmdbCache.ts exports get/set functions with TTL
    2. Check tmdb.ts imports and uses tmdbCache
    3. Verify 24-hour TTL is used (86400000 ms)
    4. Verify stale data is NOT returned (strict fresh)
    5. Verify fallback is silent (no error thrown to UI)
  </verify>
  <done>
    TMDB API responses are cached in-memory for 24 hours. When API is unavailable, cached data is returned silently. Stale cache is not served.
  </done>
</task>

</tasks>

<verification>
1. AsyncErrorBoundary shows error codes (e.g., "ERR-1700000001")
2. Manual dismiss button closes error (no auto-dismiss)
3. Error message includes component name
4. TMDB uses in-memory cache with 24h expiration
5. TMDB returns fresh cache only, no stale-while-revalidate
6. Fallback is silent - no error UI shown to user
</verification>

<success_criteria>
- Extended AsyncErrorBoundary implements all user decisions (error codes, manual dismiss, component name, positioning)
- TMDB uses in-memory 24h cache with strict fresh behavior
- No new external dependencies added
- All existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling/02-01-SUMMARY.md`
</output>
